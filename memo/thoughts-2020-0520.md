现在的思路又有进一步的升华, 对机器人的理解更深刻了.
但不能继续再想下去, 会严重干扰目前的开发思路.

简单来说, 对话机器人就是一个解释器, 有点像编程语言的 debug 模式,
只是控制语句需要用户动态输入.

所以机器人要随时维护一个上下文状态, 和编程语言的特性高度一致.

* 机器人架构

----

很多思路还不确定, 包括异步的解决方案, 现在看起来还需要进一步的思考.

Ghost 全解耦看来是有必要的.
Ghost 不应该了解和 shell 有关的任何细节, 而交给上一级的单元去处理.
有必要的功能在具体的场景中再去增加, 而没必要预先设计.

先按这个思路往下走. 

* 多端架构

----

关于多端架构问题有了新的认识.

由于每个端情况不同, 大致可以分为:
- 全异步 : 可随时主动推送
- 在线双工 : 只要在线, 就能够主动推送.
- 全同步 : 只有同步请求时才能获得信息

尽管一个机器人可以用任何一种端来搭建, 但要把多个端同构起来, 则可能有多种身份:

- 异步端 : 接受完整的全量推送.
- 双工端 : 在线时接受所有消息
- 纯输入端 : 因为无法接受广播, 本质上沦为一个输入端.
- 收件箱 : 被动等待查询

机器人的消息推送也会因为 shell 的原因, 有一个优先级策略:

```
clone
shells;
messenger;


foreach(shells as $shell) {
    // 异步
    if (shell.isAvailable) {
        clone.available = true;
    }
}

if (!clone.isAvailable) {

}

outputs = clone.handle(input);
```

这个策略可以用 Messenger 模块做处理, 而让 Clone 完全解耦.

或者 Messenger 应该叫 Brainstem 之类的?

* 多端架构

----

关于多轮对话的异步问题, 又好好思考了一番. 异步原来也有多种情况, 会导致更麻烦的场景.

- 全双工: 异步消息可以立刻发送, 并且变更对话状态
- 在线双工: 只有用户在线时可以启动异步任务, 否则要进入收件箱
- 同步: 只有用户主动发出消息时, 可以启动异步任务.

对于 Clone 而言, 预期有可感知, 无感知的几种做法.
我们先考虑无感知的做法, 假设 Clone 不了解 shell 和通道的任何情况, 完全解耦.

Clone 会第一时间处理异步消息, 引发状态变更, 并将消息发送给用户. 吗?
可以设计几种情况:

1. await 状态存在, 从而产生一个 blocking 流程.
    - 可推送到 : 立刻变更状态, 并且发送消息给用户
    - 不可推送到 : 等到下一次请求时, 才能抢占.
1. await 状态不存在
    - clone 存在
        - 可推送到 : 立刻变更状态, 并且发送消息给用户
        - 不可推送到 :
    - clone 不存在

有问题. 维度比这个还要复杂得多. 有以下各种情况:

1. clone 是否存在.
1. conversation 是否存在
1. await 是否存在.
1. isDuplex

多个 shell 完全同构也不现实, 必须以一个 shell 为基础, 其它 shell 只是接入.

* 多轮对话

----

重新整理一下对话系统涉及的所有维度:

- cloneId : Cloner 的唯一ID, 必须
- traceId : 请求的 trace. 例如 messageId
- conversationId : 一次对话的 id

- clone : 对话机器人的唯一分身
- session : 分身的会话信息模块, 单次对话相关.
- conversation : 一轮对话

* 多轮对话
